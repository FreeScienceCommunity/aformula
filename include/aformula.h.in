/*
  Copyright (C) 2010  Charles Pence <charles@charlespence.net>
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef AFORMULA_H__
#define AFORMULA_H__

#include <string>
#include <boost/utility.hpp>

/// @mainpage AFormula
/// @author Charles Pence
/// @date August 8, 2010
///
/// Welcome to the documentation for AFormula!
///
/// AFormula is a library designed for high-performance evaluation of
/// mathematical formulas, especially in numerical simulation and
/// similar applications.  It is heavily inspired by muParser, but is
/// able to utilize multiple different formula-evaluation backends,
/// including muParser itself, and the LLVM and libjit just-in-time
/// compilers.  Just-in-time compilation permits much faster formula
/// evaluation, and the LLVM library, in particular, has been ported
/// to many CPU architectures.
///
/// Support is included for all the standard arithmetic and
/// comparative operators, including @c <=, @c >=, @c !=, @c ==,
/// @c <, @c >, @c +, @c -, @c *, @c /, and @c ^ (exponentiation).
/// Arbitrary variables may be defined (as pointers to double-values),
/// and the assignment operator, @c =, may be used to assign values to
/// them.  A full suite of builtin functions is supported:
///
/// @li Trigonometry (sin, cos, tan, asin, acos, atan)
/// @li Hyperbolic trigonometry (sinh, cosh, tanh, asinh, acosh, atanh)
/// @li Logarithms (log2, log10 [= log], ln, exp, sqrt)
/// @li Miscellaneous (sign, rint, abs)
/// @li Logical control: if(x,if-true,if-false)
///
/// Finally, the constants @c pi and @c e are supported.
///
/// The order of operations is:
///
/// @li = (assignment, lowest)
/// @li <=, >=, !=, ==, <, > (comparisons)
/// @li +, - (addition/subtraction)
/// @li *, / (multiplication/division)
/// @li ^ (exponentiation)
///
/// AFormula is designed to be quite robust to invalid formulas, and is
/// careful to return appropriate errors when necessary.
///
/// There are two JIT backends which AFormula can use in order to compile
/// functions on the fly: LLVM and libjit.  In general, both should provide
/// roughly the same performance, though there is a performance test
/// included which will benchmark the library and permit selection at
/// runtime.
///
/// @section Requirements
///
/// The Boost C++ Libraries <http://www.boost.org> are required to build
/// AFormula.
///
/// If you want either of the dynamic-compilation backends to be built,
/// you will need to install either LLVM <http://www.llvm.org>, or libjit 
/// <http://freshmeat.net/projects/libjit/>.  Note that at the time of this
/// writing I was not able to get libjit to compile without a fair bit of
/// hacking around on its source code.
///
/// Neither of these libraries are necessary (the included muParser backend
/// will be built regardless), but they will provide a large speed boost.
///
/// @section Thanks
///
/// Thanks are most obviously due to the author of muParser, Ingo Berg.
/// Without muParser having been written, I never would have been able to
/// start on the project that produced the need for AFormula.  muParser,
/// which is licensed under the MIT license, is Copyright (C) 2004-2006 Ingo
/// Berg.
///
/// Also, thanks is due to the pair of massively cross-platform JIT
/// compilation libraries, LLVM and libjit, without which a JIT-compilation
/// backend (for something like an order of magnitude of performance) would
/// be impossible.
///
/// @section Interface
///
/// The main class exported by AFormula is @c AFormula::Formula.  See
/// its documentation for more information.


/// @namespace AFormula
/// @brief Namespace enclosing all AFormula code.
namespace AFormula
{


/// @class Formula
/// @brief A mathematical formula which can be evaluated.
///
/// This class, with a relatively simple public API, is the main point
/// of interaction with AFormula.  It encapsulates a single
/// mathematical formula, with a given expression and set of
/// variables.
class Formula : public boost::noncopyable
{
public:
	/// @brief Destructor.
	virtual ~Formula ();


	/// @brief Available formula-execution backends.
	///
	/// @note Some of these backends may be surrounded by <tt>\#if
	/// 0</tt> preprocessor blocks on your system.  If so, do not
	/// remove them!  These backends were disabled at compile-time on
	/// your system, and support for them is not included in AFormula.
	/// Enabling them will cause AFormula-based programs to crash.
	///
	/// If you want to enable more backend support, install LLVM
	/// and/or libjit, and consult the @c --with-llvm and @c
	/// --with-libjit options to the @c configure script.
	enum
	{
		/// @brief Default formula backend.
		///
		/// Usually, muParser will be the default backend, but if you
		/// run the @c Formula::fastestBackend benchmark, passing @c
		/// true for the @c setAsDefault parameter, future calls using
		/// @c BACKEND_DEFAULT will use the known-fastest backend.
		BACKEND_DEFAULT = 0,

		/// @brief muParser backend.
		BACKEND_MUPARSER,
#if @LLVM_DEF@
		/// @brief LLVM backend.
		BACKEND_LLVM,
#endif
#if @LIBJIT_DEF@
		/// @brief libjit backend.
		BACKEND_LIBJIT,
#endif
		/// @brief Number of available backends.
		NUM_BACKENDS
	};
	
	/// @brief Create a new formula.
	/// 
	/// @param[in] withBackend Backend which will evaluate formula.
	/// @return Newly created formula.
	///
	/// @note The returned formula should be deleted using 'delete'
	/// when it is no longer needed.
	///
	/// See the documentation for the value @c
	/// Formula::BACKEND_DEFAULT for an explanation of how the default
	/// formula backend is selected.
	static Formula *createFormula (int withBackend = BACKEND_DEFAULT);

	/// @brief Determine fastest evaluation backend.
	///
	/// @param[in] setAsDefault If true, set the value of @c
	/// Formula::BACKEND_DEFAULT to the fastest available backend
	/// @return @c BACKEND_* value of the fastest available backend
	///
	/// This function will run a run-time benchmark to determine which
	/// formula evaluation backend is fastest.  Note that this is a
	/// blocking call, and it will take some time.
	///
	/// As mentioned here and in the documentation for @c
	/// Formula::BACKEND_DEFAULT, if @c setAsDefault is @c true, then
	/// future calls to @c Formula::createFormula passing @c
	/// BACKEND_DEFAULT will use the tested-fastest backend.
	static int fastestBackend (bool setAsDefault = true);



	/// @brief Return any current error string.
	///
	/// This function implements an error stack somewhat like @c
	/// glGetError().  It will return any current error string (or the
	/// empty string if no error state exists), and will then reset
	/// the internal error state to the empty string if the user
	/// wishes to recover and try again.
	std::string errorString ();
	

	
	/// @brief Set and parse the mathematical formula to solve.
	///
	/// @param[in] str Function to evaluate.
	/// @return True if the function could be properly parsed and set,
	/// false otherwise.
	///
	/// This function not only sets the current expression, but parses
	/// and syntax-checks this expression.  Note that all variables
	/// must be set before calling this function!  After calling this
	/// function, the formula will be parsed into some sort of bytecode
	/// or machine code, so future calls to @c Formula::evaluate should
	/// be quite fast.
	virtual bool setExpression (const std::string &str) = 0;

	/// @brief Get the formula currently being solved.
	///
	/// @return The formula set by the last call to @c
	/// Formula::setExpression.
	virtual std::string expression () const = 0;

	
	
	/// @brief Set a variable to a given pointer.
	///
	/// @param[in] variable Name of the variable to be set.
	/// @param[in] pointer Pointer to the double value for this variable.
	/// @return True if the variable could be properly registered, false
	/// otherwise.
	///
	/// This function registers a new variable for use in a formula.
	/// Since variables in a formula are read/write (that is, we have an
	/// assignment operator), you must supply a pointer to a double value
	/// which holds the current value of the given variable, and will
	/// hold any changes to the variable which are caused by evaluating
	/// the formula.
	///
	/// A variable may fail to be registered if the variable has the same
	/// name as another variable, one of the AFormula built-in functions,
	/// or one of the built-in mathematical constants.
	virtual bool setVariable (const std::string &variable, double *pointer) = 0;

	
	/// @brief Evaluate this formula.
	///
	/// @return The result of the formula evaluation.
	///
	/// This will evaluate the formula as given, and return the result.
	/// Note that if this function fails, a NaN value will be returned,
	/// and the appropriate error will be set in @c Function::errorString.
	virtual double evaluate () = 0;

protected:

	/// @brief Constructor.
	///
	/// The constructor is protected; you may only create new @c Formula
	/// objects by calling @c Formula::createFormula.
	Formula ();
};

};

#endif /* AFORMULA_H__ */

// Local Variables:
// mode: c++
// End:
